// Generated by CoffeeScript 1.10.0
var AnnotationSync;

module.exports = AnnotationSync = (function() {
  AnnotationSync.prototype.cache = null;

  function AnnotationSync(bridge, options) {
    var event, func, handler, method, ref, ref1;
    this.bridge = bridge;
    if (!options.on) {
      throw new Error('options.on unspecified for AnnotationSync.');
    }
    if (!options.emit) {
      throw new Error('options.emit unspecified for AnnotationSync.');
    }
    this.cache = {};
    this._on = options.on;
    this._emit = options.emit;
    ref = this._eventListeners;
    for (event in ref) {
      handler = ref[event];
      this._on(event, handler.bind(this));
    }
    ref1 = this._channelListeners;
    for (method in ref1) {
      func = ref1[method];
      this.bridge.on(method, func.bind(this));
    }
  }

  AnnotationSync.prototype.sync = function(annotations) {
    var a;
    annotations = (function() {
      var i, len, results1;
      results1 = [];
      for (i = 0, len = annotations.length; i < len; i++) {
        a = annotations[i];
        results1.push(this._format(a));
      }
      return results1;
    }).call(this);
    this.bridge.call('sync', annotations, (function(_this) {
      return function(err, annotations) {
        var i, len, results1;
        if (annotations == null) {
          annotations = [];
        }
        results1 = [];
        for (i = 0, len = annotations.length; i < len; i++) {
          a = annotations[i];
          results1.push(_this._parse(a));
        }
        return results1;
      };
    })(this));
    return this;
  };

  AnnotationSync.prototype._channelListeners = {
    'deleteAnnotation': function(body, cb) {
      var annotation;
      annotation = this._parse(body);
      delete this.cache[annotation.$tag];
      this._emit('annotationDeleted', annotation);
      return cb(null, this._format(annotation));
    },
    'loadAnnotations': function(bodies, cb) {
      var a, annotations;
      annotations = (function() {
        var i, len, results1;
        results1 = [];
        for (i = 0, len = bodies.length; i < len; i++) {
          a = bodies[i];
          results1.push(this._parse(a));
        }
        return results1;
      }).call(this);
      this._emit('annotationsLoaded', annotations);
      return cb(null, annotations);
    }
  };

  AnnotationSync.prototype._eventListeners = {
    'beforeAnnotationCreated': function(annotation) {
      if (annotation.$tag != null) {
        return;
      }
      return this._mkCallRemotelyAndParseResults('beforeCreateAnnotation')(annotation);
    }
  };

  AnnotationSync.prototype._mkCallRemotelyAndParseResults = function(method, callBack) {
    return (function(_this) {
      return function(annotation) {
        var wrappedCallback;
        wrappedCallback = function(failure, results) {
          if (failure == null) {
            _this._parseResults(results);
          }
          return typeof callBack === "function" ? callBack(failure, results) : void 0;
        };
        return _this.bridge.call(method, _this._format(annotation), wrappedCallback);
      };
    })(this);
  };

  AnnotationSync.prototype._parseResults = function(results) {
    var bodies, body, i, j, len, len1;
    for (i = 0, len = results.length; i < len; i++) {
      bodies = results[i];
      bodies = [].concat(bodies);
      for (j = 0, len1 = bodies.length; j < len1; j++) {
        body = bodies[j];
        if (body !== null) {
          this._parse(body);
        }
      }
    }
  };

  AnnotationSync.prototype._tag = function(ann, tag) {
    if (ann.$tag) {
      return ann;
    }
    tag = tag || window.btoa(Math.random());
    Object.defineProperty(ann, '$tag', {
      value: tag
    });
    this.cache[tag] = ann;
    return ann;
  };

  AnnotationSync.prototype._parse = function(body) {
    var local, merged, remote;
    local = this.cache[body.tag];
    remote = body.msg;
    merged = Object.assign(local || {}, remote);
    return this._tag(merged, body.tag);
  };

  AnnotationSync.prototype._format = function(ann) {
    this._tag(ann);
    return {
      tag: ann.$tag,
      msg: ann
    };
  };

  return AnnotationSync;

})();
